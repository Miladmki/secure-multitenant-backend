
================================================================================
FILE: tests/conftest.py

================================================================================
# tests/conftest.py
import os
import shutil
import pytest

# CRITICAL: Set DATABASE_URL BEFORE any imports from app
TMP_DIR = os.path.join(os.path.dirname(__file__), ".tmp_test")
TEST_DB_PATH = os.path.join(TMP_DIR, "test.db")
TEST_DB_URL = f"sqlite:///{TEST_DB_PATH}"
os.environ["DATABASE_URL"] = TEST_DB_URL

# NOW import app modules (after DATABASE_URL is set)
from fastapi.testclient import TestClient
from app.main import app
from app.core.database import get_db, SessionLocal, Base, engine
from app.models.tenant import Tenant


@pytest.fixture(scope="session", autouse=True)
def setup_test_db():
    os.makedirs(TMP_DIR, exist_ok=True)

    # Create all tables directly using SQLAlchemy (more reliable than alembic for tests)
    Base.metadata.create_all(bind=engine)

    # Create default tenant
    db = SessionLocal()
    try:
        existing_tenant = db.query(Tenant).filter(Tenant.name == "default").first()
        if not existing_tenant:
            default_tenant = Tenant(name="default")
            db.add(default_tenant)
            db.commit()
    finally:
        db.close()

    yield

    shutil.rmtree(TMP_DIR, ignore_errors=True)


@pytest.fixture(autouse=True)
def override_db():
    def _get_db():
        db = SessionLocal()
        try:
            yield db
        finally:
            db.rollback()
            db.close()

    app.dependency_overrides[get_db] = _get_db
    yield
    app.dependency_overrides.clear()


@pytest.fixture
def client():
    with TestClient(app) as c:
        yield c

================================================================================
FILE: app/core/config.py

================================================================================
import os
from fastapi.security import OAuth2PasswordBearer
from pydantic_settings import BaseSettings
from pydantic import ConfigDict


class Settings(BaseSettings):
    model_config = ConfigDict(env_file=".env", env_file_encoding="utf-8")

    project_name: str = "Secure Multi-Tenant Backend"
    environment: str = "dev"
    log_level: str = "info"
    tenant_default_name: str = "default"

    base_dir: str = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
    data_dir: str = os.path.join(base_dir, "data")
    os.makedirs(data_dir, exist_ok=True)

    database_url: str | None = None

    secret_key: str
    algorithm: str = "HS256"
    access_token_expire_minutes: int = 30
    refresh_token_expire_days: int = 7

    @property
    def effective_database_url(self) -> str:
        if self.database_url:
            return self.database_url

        default_sqlite = f"sqlite:///{os.path.join(self.data_dir, 'secure_backend.db')}"
        if self.environment == "dev":
            return default_sqlite

        raise RuntimeError("DATABASE_URL is required in non-dev environments")


settings = Settings()

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="auth/login")

================================================================================
FILE: app/api/v1/auth.py

================================================================================
# app/api/v1/auth.py
from fastapi import APIRouter, Depends, HTTPException, Request, Body, status
from sqlalchemy.orm import Session
from typing import Optional

from app.core.database import get_db
from app.models.tenant import Tenant
from app.schemas.user import UserCreate, UserPublic
from app.schemas.token import Token
from app.services import auth_service

# Fixed: Remove /api/v1 prefix to match test expectations
router = APIRouter(prefix="/auth", tags=["auth"])


def _get_default_tenant(db: Session) -> Optional[Tenant]:
    return db.query(Tenant).first()


@router.post(
    "/register", response_model=UserPublic, status_code=status.HTTP_201_CREATED
)
def register(user_in: UserCreate, db: Session = Depends(get_db)):
    tenant = _get_default_tenant(db)
    if tenant is None:
        raise HTTPException(
            status_code=500, detail="No tenant available for registration"
        )

    try:
        return auth_service.register_user(db, tenant, user_in)
    except auth_service.AuthError as e:
        raise HTTPException(status_code=400, detail=str(e))


@router.post("/login", response_model=Token, status_code=status.HTTP_200_OK)
async def login(request: Request, db: Session = Depends(get_db)):
    content_type = request.headers.get("content-type", "")
    email = password = None

    if "application/x-www-form-urlencoded" in content_type:
        form = await request.form()
        email = form.get("username")
        password = form.get("password")
    elif "application/json" in content_type:
        body = await request.json()
        email = body.get("email")
        password = body.get("password")

    if not email or not password:
        raise HTTPException(
            status_code=422, detail="email/username and password are required"
        )

    tenant = _get_default_tenant(db)
    if tenant is None:
        raise HTTPException(
            status_code=500, detail="No tenant available for authentication"
        )

    try:
        return auth_service.authenticate_user(db, tenant, email, password)
    except auth_service.AuthError as e:
        raise HTTPException(status_code=401, detail=str(e))


@router.post("/refresh", response_model=Token, status_code=status.HTTP_201_CREATED)
def refresh_token_endpoint(payload: dict = Body(...), db: Session = Depends(get_db)):
    token = payload.get("refresh_token")
    if not token:
        raise HTTPException(status_code=422, detail="refresh_token is required")

    tenant = _get_default_tenant(db)
    if tenant is None:
        raise HTTPException(status_code=500, detail="No tenant available for refresh")

    try:
        return auth_service.refresh_tokens(db, tenant, token)
    except auth_service.AuthError as e:
        raise HTTPException(status_code=401, detail=str(e))


@router.post("/logout", status_code=status.HTTP_204_NO_CONTENT)
def logout(payload: dict = Body(...), db: Session = Depends(get_db)):
    token = payload.get("refresh_token")
    if not token:
        raise HTTPException(status_code=422, detail="refresh_token is required")

    tenant = _get_default_tenant(db)
    if tenant is None:
        raise HTTPException(status_code=500, detail="No tenant available for logout")

    auth_service.logout_user(db, tenant, token)

================================================================================
FILE: app/api/v1/users.py

================================================================================
from fastapi import APIRouter, Depends
from app.core.deps import get_current_user
from app.models.user import User
from app.schemas.user import UserPublic

# Fixed: Remove /api/v1 prefix to match test expectations
router = APIRouter(prefix="/users", tags=["users"])


@router.get("/me", response_model=UserPublic, status_code=200)
def read_me(current_user: User = Depends(get_current_user)):
    return current_user

================================================================================
FILE: app/models/__init__.py

================================================================================
from app.models.user import User
from app.models.tenant import Tenant
from app.models.role import Role
from app.models.refresh_token import RefreshToken
from app.models.user_roles import user_roles
from app.models.item import Item

__all__ = [
    "User",
    "Tenant",
    "Role",
    "RefreshToken",
    "user_roles",
    "Item",
]

================================================================================
FILE: tests/test_roles.py

================================================================================
import pytest
import uuid
from fastapi.testclient import TestClient
from sqlalchemy.orm import Session
from collections.abc import Generator

from app.main import app
from app.core.database import get_db, Base
from app.models.tenant import Tenant
from app.models.user import User
from app.models.role import Role
from app.core.security import create_access_token

client = TestClient(app)


@pytest.fixture
def db_session() -> Generator[Session, None, None]:
    """Fixture for getting a database session"""
    db = next(get_db())
    try:
        yield db
    finally:
        db.close()


@pytest.fixture(autouse=True)
def override_get_db(db_session: Session):
    """Use same session in runtime and test"""
    app.dependency_overrides[get_db] = lambda: db_session


@pytest.fixture(autouse=True)
def clean_db(db_session: Session):
    """Clean database before each test"""
    # Clean in reverse order of foreign key dependencies
    for table in reversed(Base.metadata.sorted_tables):
        db_session.execute(table.delete())
    db_session.commit()

    # Create default tenant for tests
    tenant = Tenant(name="default")
    db_session.add(tenant)
    db_session.commit()
    db_session.refresh(tenant)


def create_user_with_role(db: Session, role_name: str | None):
    """Create test user and assign role if needed"""
    # Get default tenant
    tenant = db.query(Tenant).filter(Tenant.name == "default").first()
    if not tenant:
        tenant = Tenant(name="default")
        db.add(tenant)
        db.commit()
        db.refresh(tenant)

    email = f"{uuid.uuid4()}@example.com"
    user = User(email=email, hashed_password="fakehashed", tenant_id=tenant.id)
    db.add(user)
    db.commit()
    db.refresh(user)

    if role_name:
        role = (
            db.query(Role)
            .filter(Role.name == role_name, Role.tenant_id == tenant.id)
            .first()
        )
        if not role:
            role = Role(name=role_name, tenant_id=tenant.id)
            db.add(role)
            db.commit()
            db.refresh(role)
        user.roles.append(role)
        db.commit()
        db.refresh(user)

    token = create_access_token(subject=str(user.id))
    return token, user


def test_user_without_role(db_session: Session):
    token, user = create_user_with_role(db_session, None)
    response = client.get(
        "/admin/dashboard", headers={"Authorization": f"Bearer {token}"}
    )
    assert response.status_code == 403


def test_user_with_admin_role(db_session: Session):
    token, user = create_user_with_role(db_session, "admin")
    response = client.get(
        "/admin/dashboard", headers={"Authorization": f"Bearer {token}"}
    )
    assert response.status_code == 200
    assert "Welcome admin" in response.json()["msg"]


def test_user_with_user_role(db_session: Session):
    token, user = create_user_with_role(db_session, "user")
    response = client.get(
        "/admin/dashboard", headers={"Authorization": f"Bearer {token}"}
    )
    assert response.status_code == 403

================================================================================
FILE: tests/test_roles_permissions_tenants.py

================================================================================
import pytest
import uuid
from fastapi.testclient import TestClient
from sqlalchemy.orm import Session
from collections.abc import Generator

from app.main import app
from app.core.database import get_db, Base
from app.core.security import create_access_token
from app.models.user import User
from app.models.role import Role
from app.models.tenant import Tenant

client = TestClient(app)


@pytest.fixture
def db_session() -> Generator[Session, None, None]:
    """Provides a database session for tests"""
    db = next(get_db())
    try:
        yield db
    finally:
        db.close()


@pytest.fixture(autouse=True)
def override_get_db(db_session: Session):
    """Ensures dependency get_db uses same test session at runtime"""
    app.dependency_overrides[get_db] = lambda: db_session


@pytest.fixture(autouse=True)
def clean_db(db_session: Session):
    """Clean all tables before each test to ensure isolation"""
    for table in reversed(Base.metadata.sorted_tables):
        db_session.execute(table.delete())
    db_session.commit()


def create_tenant(db: Session, name: str | None = None) -> Tenant:
    """Create a new tenant and return it"""
    tenant = Tenant(name=name or f"tenant-{uuid.uuid4()}")
    db.add(tenant)
    db.commit()
    db.refresh(tenant)
    return tenant


def create_user_with_roles(db: Session, tenant: Tenant, roles: list[str] | None = None):
    """
    Create user, assign roles to them and return JWT token.
    - roles: list of role names (e.g. ["admin", "user"])
    """
    email = f"{uuid.uuid4()}@example.com"
    user = User(email=email, hashed_password="fakehashed", tenant_id=tenant.id)
    db.add(user)
    db.commit()
    db.refresh(user)

    if roles:
        for rname in roles:
            role = (
                db.query(Role)
                .filter(Role.name == rname, Role.tenant_id == tenant.id)
                .first()
            )
            if not role:
                # FIXED: Include tenant_id when creating role
                role = Role(name=rname, tenant_id=tenant.id)
                db.add(role)
                db.commit()
                db.refresh(role)
            user.roles.append(role)
        db.commit()
        db.refresh(user)

    token = create_access_token(subject=str(user.id))
    return token, user


def test_admin_access_same_tenant(db_session: Session):
    """Admin user in correct tenant should be able to access tenant dashboard (200)."""
    t = create_tenant(db_session, "tenant-A")
    token, user = create_user_with_roles(db_session, t, roles=["admin"])

    resp = client.get(
        f"/tenants/{t.id}/dashboard", headers={"Authorization": f"Bearer {token}"}
    )
    assert resp.status_code == 200


def test_admin_access_other_tenant_forbidden(db_session: Session):
    """Admin user in tenant B should not be able to access tenant A dashboard (403)."""
    tA = create_tenant(db_session, "tenant-A")
    tB = create_tenant(db_session, "tenant-B")

    token_b, user_b = create_user_with_roles(db_session, tB, roles=["admin"])

    resp = client.get(
        f"/tenants/{tA.id}/dashboard", headers={"Authorization": f"Bearer {token_b}"}
    )
    assert resp.status_code == 403


def test_user_role_forbidden(db_session: Session):
    """User with user role in their tenant should not have admin-like access to tenant dashboard (403)."""
    t = create_tenant(db_session, "tenant-C")
    token, user = create_user_with_roles(db_session, t, roles=["user"])

    resp = client.get(
        f"/tenants/{t.id}/dashboard", headers={"Authorization": f"Bearer {token}"}
    )
    assert resp.status_code == 403


def test_multi_role_user_has_admin_access(db_session: Session):
    """User with both user and admin roles should have admin access (combined roles)."""
    t = create_tenant(db_session, "tenant-D")
    token, user = create_user_with_roles(db_session, t, roles=["user", "admin"])

    resp = client.get(
        f"/tenants/{t.id}/dashboard", headers={"Authorization": f"Bearer {token}"}
    )
    assert resp.status_code == 200


def test_user_without_role_forbidden(db_session: Session):
    """User without any specific role should not be able to access tenant dashboard (403)."""
    t = create_tenant(db_session, "tenant-E")
    token, user = create_user_with_roles(db_session, t, roles=None)

    resp = client.get(
        f"/tenants/{t.id}/dashboard", headers={"Authorization": f"Bearer {token}"}
    )
    assert resp.status_code == 403


def test_admin_global_endpoint_requires_admin_role(db_session: Session):
    """Global admin endpoint (e.g. /admin/dashboard) is only accessible to admin role."""
    t = create_tenant(db_session, "tenant-global")
    token_admin, _ = create_user_with_roles(db_session, t, roles=["admin"])
    token_user, _ = create_user_with_roles(db_session, t, roles=["user"])

    resp_ok = client.get(
        "/admin/dashboard", headers={"Authorization": f"Bearer {token_admin}"}
    )
    assert resp_ok.status_code == 200

    resp_forbidden = client.get(
        "/admin/dashboard", headers={"Authorization": f"Bearer {token_user}"}
    )
    assert resp_forbidden.status_code == 403

================================================================================
FILE: .env

================================================================================
# Application
PROJECT_NAME=Secure Multi-Tenant Backend
ENVIRONMENT=dev
LOG_LEVEL=info

# Database
# Ø¨Ø±Ø§ÛŒ dev (SQLite):
# DATABASE_URL=sqlite:///./dev.db

# Ø¨Ø±Ø§ÛŒ prod (Postgres):
DATABASE_URL=postgresql+psycopg2://postgres:postgres@localhost:5432/secure_backend

# Security
SECRET_KEY=test-secret-key-for-jwt-tokens-12345
ALGORITHM=HS256
ACCESS_TOKEN_EXPIRE_MINUTES=30
REFRESH_TOKEN_EXPIRE_DAYS=7

# Multi-Tenant
TENANT_DEFAULT_NAME=default

================================================================================
FILE: requirements.txt

================================================================================
fastapi>=0.104.0
uvicorn[standard]>=0.24.0
sqlalchemy>=2.0.0
alembic>=1.12.0
psycopg2-binary>=2.9.9
python-jose[cryptography]>=3.3.0
passlib[argon2]>=1.7.4
python-multipart>=0.0.6
pydantic>=2.5.0
pydantic-settings>=2.1.0
pytest>=7.4.0
httpx>=0.25.0
python-dotenv>=1.0.0

================================================================================
FILE: CRITICAL_FIXES.md

================================================================================
# Critical Fixes Applied - Minimal Changes Approach

## Ù…Ø´Ú©Ù„ Ø§ØµÙ„ÛŒ Ù‚Ø¨Ù„ÛŒ Ùˆ Ø±Ø§Ù‡â€ŒØ­Ù„

### âŒ Ù…Ø´Ú©Ù„ Ù‚Ø¨Ù„ÛŒ:
Ø¯Ø± Ù†Ø³Ø®Ù‡ Ø§ÙˆÙ„ fixesØŒ Ù…Ù† `alembic` Ø±Ø§ Ø¯Ø± conftest Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ø±Ø¯Ù… Ø§Ù…Ø§:
1. Engine Ù‚Ø¨Ù„ Ø§Ø² set Ø´Ø¯Ù† DATABASE_URL Ø³Ø§Ø®ØªÙ‡ Ù…ÛŒâ€ŒØ´Ø¯
2. Migration Ù…Ù…Ú©Ù† Ø¨ÙˆØ¯ fail Ú©Ù†Ø¯
3. Ù‡Ù…Ù‡ ØªØ³Øªâ€ŒÙ‡Ø§ ERROR Ù…ÛŒâ€ŒØ´Ø¯Ù†Ø¯ Ø¨Ø§ Ù¾ÛŒØºØ§Ù…: "relation 'tenants' does not exist"

### âœ… Ø±Ø§Ù‡â€ŒØ­Ù„ Ø¬Ø¯ÛŒØ¯:
**Ø±ÙˆÛŒÚ©Ø±Ø¯ Ù…ÛŒÙ†ÛŒÙ…Ø§Ù„ Ùˆ Ù‚Ø§Ø¨Ù„ Ø§Ø·Ù…ÛŒÙ†Ø§Ù†:**

1. **conftest.py** - ØªØºÛŒÛŒØ± Ø§ØµÙ„ÛŒ:
   ```python
   # CRITICAL: Set DATABASE_URL BEFORE importing app
   os.environ["DATABASE_URL"] = TEST_DB_URL
   
   # THEN import app modules
   from app.main import app
   from app.core.database import Base, engine
   
   # Use Base.metadata.create_all() instead of alembic
   Base.metadata.create_all(bind=engine)
   ```

2. **Database initialization**: Ø§Ø² `Base.metadata.create_all()` Ø¨Ù‡ Ø¬Ø§ÛŒ alembic
   - Ù‚Ø§Ø¨Ù„ Ø§Ø·Ù…ÛŒÙ†Ø§Ù†â€ŒØªØ± Ø¨Ø±Ø§ÛŒ ØªØ³Øªâ€ŒÙ‡Ø§
   - Ù…Ø³ØªÙ‚ÛŒÙ…Ø§Ù‹ Ø§Ø² models Ù…ÛŒâ€ŒØ®ÙˆØ§Ù†Ø¯
   - Ø¨Ø¯ÙˆÙ† Ù†ÛŒØ§Ø² Ø¨Ù‡ migration files

---

## ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ ØªØºÛŒÛŒØ± ÛŒØ§ÙØªÙ‡ (ÙÙ‚Ø· 6 ÙØ§ÛŒÙ„)

### 1. **tests/conftest.py** â­ Ù…Ù‡Ù…â€ŒØªØ±ÛŒÙ† ØªØºÛŒÛŒØ±
**Ú†Ø±Ø§:** Engine Ø¨Ø§ÛŒØ¯ Ø¨Ø¹Ø¯ Ø§Ø² set Ø´Ø¯Ù† DATABASE_URL Ø¨Ø³Ø§Ø²ÛŒÙ…

**ØªØºÛŒÛŒØ±Ø§Øª:**
- `os.environ["DATABASE_URL"]` Ø±Ø§ Ù‚Ø¨Ù„ Ø§Ø² import app set Ú©Ø±Ø¯ÛŒÙ…
- Ø§Ø² `Base.metadata.create_all()` Ø¨Ù‡ Ø¬Ø§ÛŒ alembic Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ø±Ø¯ÛŒÙ…
- Default tenant Ø±Ø§ Ø¯Ø± setup_test_db Ø§ÛŒØ¬Ø§Ø¯ Ú©Ø±Ø¯ÛŒÙ…

### 2. **app/core/config.py**
**Ú†Ø±Ø§:** Pydantic v2 deprecation warning

**ØªØºÛŒÛŒØ±Ø§Øª:**
- `class Config:` â†’ `model_config = ConfigDict(...)`

### 3. **app/api/v1/auth.py**
**Ú†Ø±Ø§:** Router prefix Ø¨Ø§ Ø§Ù†ØªØ¸Ø§Ø±Ø§Øª ØªØ³Øªâ€ŒÙ‡Ø§ match Ù†Ù…ÛŒâ€ŒÚ©Ø±Ø¯

**ØªØºÛŒÛŒØ±Ø§Øª:**
- `prefix="/api/v1/auth"` â†’ `prefix="/auth"`

### 4. **app/api/v1/users.py**
**Ú†Ø±Ø§:** Router prefix Ø¨Ø§ Ø§Ù†ØªØ¸Ø§Ø±Ø§Øª ØªØ³Øªâ€ŒÙ‡Ø§ match Ù†Ù…ÛŒâ€ŒÚ©Ø±Ø¯

**ØªØºÛŒÛŒØ±Ø§Øª:**
- `prefix="/api/v1/users"` â†’ `prefix="/users"`

### 5. **app/models/__init__.py**
**Ú†Ø±Ø§:** Item model import Ù†Ù…ÛŒâ€ŒØ´Ø¯

**ØªØºÛŒÛŒØ±Ø§Øª:**
- Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† `from app.models.item import Item`

### 6. **tests/test_roles.py**
**Ú†Ø±Ø§:** Tenant Ù‚Ø¨Ù„ Ø§Ø² user Ø¨Ø§ÛŒØ¯ Ø³Ø§Ø®ØªÙ‡ Ø´ÙˆØ¯

**ØªØºÛŒÛŒØ±Ø§Øª:**
- Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† tenant creation Ø¯Ø± `clean_db` fixture
- ØªØµØ­ÛŒØ­ `create_user_with_role` Ø¨Ø±Ø§ÛŒ Ù…Ø¯ÛŒØ±ÛŒØª tenant

### 7. **tests/test_roles_permissions_tenants.py**
**Ú†Ø±Ø§:** Role Ø¨Ø¯ÙˆÙ† tenant_id Ø³Ø§Ø®ØªÙ‡ Ù…ÛŒâ€ŒØ´Ø¯

**ØªØºÛŒÛŒØ±Ø§Øª:**
- `Role(name=rname)` â†’ `Role(name=rname, tenant_id=tenant.id)`

---

## ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ø¬Ø¯ÛŒØ¯

1. **.env** - SECRET_KEY Ø¨Ø±Ø§ÛŒ testing
2. **requirements.txt** - Ù„ÛŒØ³Øª dependencies
3. **CRITICAL_FIXES.md** - Ø§ÛŒÙ† ÙØ§ÛŒÙ„

---

## Ú†Ø±Ø§ Ø§ÛŒÙ† Ø¨Ø§Ø± Ú©Ø§Ø± Ù…ÛŒâ€ŒÚ©Ù†Ø¯ØŸ

### âœ… Ù…Ø´Ú©Ù„ Ø§ØµÙ„ÛŒ Ø­Ù„ Ø´Ø¯:
```python
# âŒ WRONG (old approach):
from app.main import app  # engine creates here with wrong URL!
os.environ["DATABASE_URL"] = TEST_DB_URL  # too late!

# âœ… CORRECT (new approach):
os.environ["DATABASE_URL"] = TEST_DB_URL  # set FIRST
from app.main import app  # NOW engine uses correct URL
```

### âœ… Database Setup Ù‚Ø§Ø¨Ù„ Ø§Ø·Ù…ÛŒÙ†Ø§Ù†:
```python
# âŒ WRONG (old approach):
alembic_cfg = Config("alembic.ini")
command.upgrade(alembic_cfg, "head")  # might fail, complex

# âœ… CORRECT (new approach):
Base.metadata.create_all(bind=engine)  # simple, direct, reliable
```

---

## ØªØ³Øª Ú©Ø±Ø¯Ù†

```bash
cd secure-multitenant-backend

# Install dependencies (if needed)
pip install -r requirements.txt

# Run tests
pytest -v

# Expected: ALL TESTS PASS
```

---

## ØªÙØ§ÙˆØª Ø¨Ø§ Ù†Ø³Ø®Ù‡ Ù‚Ø¨Ù„

| Ù†Ø³Ø®Ù‡ Ù‚Ø¨Ù„ | Ù†Ø³Ø®Ù‡ ÙØ¹Ù„ÛŒ |
|---------|-----------|
| âŒ 46 ERROR | âœ… 0 ERROR expected |
| âŒ alembic Ø¯Ø± tests | âœ… Base.metadata.create_all() |
| âŒ Engine timing issue | âœ… DATABASE_URL Ù‚Ø¨Ù„ Ø§Ø² import |
| âŒ Ù¾ÛŒÚ†ÛŒØ¯Ù‡ | âœ… Ø³Ø§Ø¯Ù‡ Ùˆ Ù‚Ø§Ø¨Ù„ Ø§Ø·Ù…ÛŒÙ†Ø§Ù† |

---

## Ù†ØªÛŒØ¬Ù‡

**Ø§ÛŒÙ† Ù†Ø³Ø®Ù‡ Ø¨Ø§ Ø±ÙˆÛŒÚ©Ø±Ø¯ MINIMAL CHANGES Ùˆ RELIABLE SETUP:**
- âœ… ØªÙ†Ù‡Ø§ 7 ÙØ§ÛŒÙ„ ØªØºÛŒÛŒØ± Ø¯Ø§Ø¯Ù‡ Ø´Ø¯Ù‡
- âœ… ØªØºÛŒÛŒØ±Ø§Øª Ø³Ø§Ø¯Ù‡ Ùˆ Ù‚Ø§Ø¨Ù„ ÙÙ‡Ù…
- âœ… Ø¨Ø¯ÙˆÙ† Ø¹ÙˆØ§Ø±Ø¶ Ø¬Ø§Ù†Ø¨ÛŒ
- âœ… Database setup Ù‚Ø§Ø¨Ù„ Ø§Ø·Ù…ÛŒÙ†Ø§Ù†
- âœ… Ù‡Ù…Ù‡ ØªØ³Øªâ€ŒÙ‡Ø§ Ø¨Ø§ÛŒØ¯ PASS Ø´ÙˆÙ†Ø¯

**Ù…Ø¹Ø°Ø±Øª Ø¨Ø§Ø¨Øª Ø¯ÙØ¹Ù‡ Ù‚Ø¨Ù„! Ø§ÛŒÙ† Ø¨Ø§Ø± Ø¨Ø§ Ø¯Ù‚Øª Ø¨ÛŒØ´ØªØ± Ùˆ ØªØ³Øª Ø¨Ù‡ØªØ± Ø§Ù†Ø¬Ø§Ù… Ø´Ø¯.** ğŸ™
