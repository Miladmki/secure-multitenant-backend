===== app\main.py =====
from fastapi import FastAPI

app = FastAPI(title="Secure Multi-Tenant Backend", version="0.1.0")

# ایمپورت روترها
from app.api.v1.auth import router as auth_router
from app.api.v1.users import router as users_router
from app.routers.admin import router as admin_router
from app.routers.tenant_dashboard import router as tenant_dashboard_router

# اضافه کردن روترها
app.include_router(auth_router, prefix="/auth", tags=["auth"])
app.include_router(users_router, prefix="/users", tags=["users"])
app.include_router(tenant_dashboard_router)  # اینجا اضافه شد
app.include_router(admin_router, prefix="/admin", tags=["admin"])


@app.get("/health", tags=["health"])
def health_check():
    return {"status": "ok"}


===== tests\conftest.py =====
# tests/conftest.py
import os
import tempfile
import shutil
import pytest
from importlib import import_module
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from fastapi.testclient import TestClient
from fastapi import FastAPI
from alembic import command
from alembic.config import Config

# create a temporary directory for test DB to avoid file lock issues
TMP_DIR = os.path.join(os.path.dirname(__file__), ".tmp_test")
os.makedirs(TMP_DIR, exist_ok=True)
TEST_DB_PATH = os.path.join(TMP_DIR, "test.db")
TEST_DB_URL = f"sqlite:///{TEST_DB_PATH}"

# Ensure application uses test DB before importing app modules
os.environ["DATABASE_URL"] = TEST_DB_URL


def run_migrations():
    alembic_ini = os.path.join(os.path.dirname(__file__), "..", "alembic.ini")
    alembic_cfg = Config(alembic_ini)
    alembic_cfg.set_main_option("sqlalchemy.url", TEST_DB_URL)
    command.upgrade(alembic_cfg, "head")


# import app after DATABASE_URL is set
try:
    main_mod = import_module("app.main")
    app = getattr(main_mod, "app", None)
except Exception as e:
    app = None
    import_err = e

if app is None or not isinstance(app, FastAPI):
    raise RuntimeError(
        "Could not import FastAPI instance from app.main. Import error: "
        f"{locals().get('import_err')}"
    )


@pytest.fixture(scope="session")
def engine():
    # remove old DB if exists
    if os.path.exists(TEST_DB_PATH):
        os.remove(TEST_DB_PATH)
    eng = create_engine(TEST_DB_URL, connect_args={"check_same_thread": False})
    yield eng
    # ensure engine disposed
    try:
        eng.dispose()
    except Exception:
        pass


@pytest.fixture(scope="session")
def TestingSessionLocal(engine):
    return sessionmaker(bind=engine, autocommit=False, autoflush=False)


@pytest.fixture(scope="session", autouse=True)
def setup_database(engine):
    # run migrations on test DB
    run_migrations()
    yield
    # teardown: dispose engine and remove tmp dir
    try:
        engine.dispose()
    except Exception:
        pass
    # remove temp dir and files
    if os.path.exists(TMP_DIR):
        shutil.rmtree(TMP_DIR, ignore_errors=True)


@pytest.fixture(autouse=True)
def override_db(TestingSessionLocal):
    """Override get_db dependency for each test to use the test session."""
    from app.core.database import get_db as real_get_db  # import after env set

    def _override():
        db = TestingSessionLocal()
        try:
            # ensure default tenant exists if app expects it
            try:
                import app.models.tenant as tenant_model

                tenant = db.query(tenant_model.Tenant).first()
                if not tenant:
                    tenant = tenant_model.Tenant(name="default")
                    db.add(tenant)
                    db.commit()
                    db.refresh(tenant)
            except Exception:
                pass
            yield db
        finally:
            # rollback any pending transaction and close
            try:
                db.rollback()
            except Exception:
                pass
            db.close()

    app.dependency_overrides[real_get_db] = _override
    yield
    app.dependency_overrides.clear()


@pytest.fixture
def client():
    # Use context manager to ensure proper shutdown and cleanup
    with TestClient(app) as c:
        yield c


===== app\core\deps.py =====
# app/core/deps.py
from fastapi import Depends, HTTPException, status
from sqlalchemy.orm import Session

from app.core.database import get_db
from app.models.user import User
from app.models.tenant import Tenant
from app.core.security import oauth2_scheme, decode_token


# -------------------------
# User dependency
# -------------------------
def get_current_user(
    db: Session = Depends(get_db),
    token: str = Depends(oauth2_scheme),
) -> User:
    """
    Resolve current user from JWT token.
    """
    try:
        payload = decode_token(token)
    except ValueError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid token",
        )

    user_id: str = payload.get("sub")
    if not user_id:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid token",
        )

    user = db.query(User).filter(User.id == int(user_id)).first()
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="User not found",
        )
    return user


# -------------------------
# Tenant dependency
# -------------------------
def get_current_tenant(
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user),
) -> Tenant:
    """
    Resolve current tenant from current user.
    """
    tenant = db.query(Tenant).filter(Tenant.id == current_user.tenant_id).first()
    if not tenant:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Tenant not found or mismatch",
        )
    return tenant


# -------------------------
# Role dependency
# -------------------------
def require_role(role_name: str):
    """
    Dependency برای enforce کردن نقش کاربر.
    استفاده: current_user = Depends(require_role("admin"))
    """
    def role_dependency(current_user: User = Depends(get_current_user)):
        if current_user.role != role_name:
            # پیام خطا ساده و امن، بدون افشای role مورد انتظار
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="Forbidden",
            )
        return current_user

    return role_dependency


===== app\core\database.py =====
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, declarative_base
from app.core.config import settings

SQLALCHEMY_DATABASE_URL = settings.effective_database_url

engine = create_engine(SQLALCHEMY_DATABASE_URL, echo=False)

SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()


def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()


===== app\api\v1\auth.py =====
from fastapi import APIRouter, Depends, HTTPException, Request
from sqlalchemy.orm import Session

from app.core.database import get_db
from app.core.deps import get_current_tenant
from app.models.tenant import Tenant
from app.schemas.user import UserCreate, UserPublic
from app.schemas.token import Token
from app.services import auth_service

router = APIRouter()


@router.post("/auth/register", response_model=UserPublic, status_code=201)
def register(
    user_in: UserCreate,
    db: Session = Depends(get_db),
    tenant: Tenant = Depends(get_current_tenant),
):
    return auth_service.register_user(db, tenant, user_in)


@router.post("/auth/login", response_model=Token, status_code=200)
async def login(
    request: Request,
    db: Session = Depends(get_db),
    tenant: Tenant = Depends(get_current_tenant),
):
    content_type = request.headers.get("content-type", "")
    email = None
    password = None

    if "application/x-www-form-urlencoded" in content_type:
        form = await request.form()
        email = form.get("username")
        password = form.get("password")
    elif "application/json" in content_type:
        body = await request.json()
        email = body.get("email")
        password = body.get("password")

    if not email or not password:
        raise HTTPException(
            status_code=422, detail="email/username and password are required"
        )

    return auth_service.authenticate_user(db, tenant, email, password)


@router.post("/auth/refresh", response_model=Token, status_code=200)
def refresh_token_endpoint(
    payload: dict,
    db: Session = Depends(get_db),
    tenant: Tenant = Depends(get_current_tenant),
):
    token = payload.get("refresh_token")
    if not token:
        raise HTTPException(status_code=422, detail="refresh_token is required")

    return auth_service.refresh_tokens(db, tenant, token)


@router.post("/auth/logout", status_code=204)
def logout(
    payload: dict,
    db: Session = Depends(get_db),
    tenant: Tenant = Depends(get_current_tenant),
):
    token = payload.get("refresh_token")
    if not token:
        raise HTTPException(status_code=422, detail="refresh_token is required")

    auth_service.logout_user(db, tenant, token)
    return


