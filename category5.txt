===== tests\conftest.py =====
# tests/conftest.py
import os
import tempfile
import shutil
import pytest
from importlib import import_module
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from fastapi.testclient import TestClient
from fastapi import FastAPI
from alembic import command
from alembic.config import Config

# create a temporary directory for test DB to avoid file lock issues
TMP_DIR = os.path.join(os.path.dirname(__file__), ".tmp_test")
os.makedirs(TMP_DIR, exist_ok=True)
TEST_DB_PATH = os.path.join(TMP_DIR, "test.db")
TEST_DB_URL = f"sqlite:///{TEST_DB_PATH}"

# Ensure application uses test DB before importing app modules
os.environ["DATABASE_URL"] = TEST_DB_URL


def run_migrations():
    alembic_ini = os.path.join(os.path.dirname(__file__), "..", "alembic.ini")
    alembic_cfg = Config(alembic_ini)
    alembic_cfg.set_main_option("sqlalchemy.url", TEST_DB_URL)
    command.upgrade(alembic_cfg, "head")


# import app after DATABASE_URL is set
try:
    main_mod = import_module("app.main")
    app = getattr(main_mod, "app", None)
except Exception as e:
    app = None
    import_err = e

if app is None or not isinstance(app, FastAPI):
    raise RuntimeError(
        "Could not import FastAPI instance from app.main. Import error: "
        f"{locals().get('import_err')}"
    )


@pytest.fixture(scope="session")
def engine():
    # remove old DB if exists
    if os.path.exists(TEST_DB_PATH):
        os.remove(TEST_DB_PATH)
    eng = create_engine(TEST_DB_URL, connect_args={"check_same_thread": False})
    yield eng
    # ensure engine disposed
    try:
        eng.dispose()
    except Exception:
        pass


@pytest.fixture(scope="session")
def TestingSessionLocal(engine):
    return sessionmaker(bind=engine, autocommit=False, autoflush=False)


@pytest.fixture(scope="session", autouse=True)
def setup_database(engine):
    # run migrations on test DB
    run_migrations()
    yield
    # teardown: dispose engine and remove tmp dir
    try:
        engine.dispose()
    except Exception:
        pass
    # remove temp dir and files
    if os.path.exists(TMP_DIR):
        shutil.rmtree(TMP_DIR, ignore_errors=True)


@pytest.fixture(autouse=True)
def override_db(TestingSessionLocal):
    """Override get_db dependency for each test to use the test session."""
    from app.core.database import get_db as real_get_db  # import after env set

    def _override():
        db = TestingSessionLocal()
        try:
            # ensure default tenant exists if app expects it
            try:
                import app.models.tenant as tenant_model

                tenant = db.query(tenant_model.Tenant).first()
                if not tenant:
                    tenant = tenant_model.Tenant(name="default")
                    db.add(tenant)
                    db.commit()
                    db.refresh(tenant)
            except Exception:
                pass
            yield db
        finally:
            # rollback any pending transaction and close
            try:
                db.rollback()
            except Exception:
                pass
            db.close()

    app.dependency_overrides[real_get_db] = _override
    yield
    app.dependency_overrides.clear()


@pytest.fixture
def client():
    # Use context manager to ensure proper shutdown and cleanup
    with TestClient(app) as c:
        yield c


===== tests\merge_tests.py =====
import os

# مسیر پوشه تست‌ها (همون پوشه‌ای که اسکریپت داخلشه)
tests_dir = os.path.dirname(__file__)

# فایل‌های تستی که می‌خوای merge بشن
test_files = [
    "conftest.py",
    "test_auth_basic.py",
    "test_auth_failures.py",
    "test_auth_flow.py",
    "test_imports.py",
    "test_refresh_flow.py",
    "test_roles_permissions_tenants.py",
    "test_roles.py",
    "test_service_dependencies.py",
    "test_tenant_isolation.py",
    "test_users_me.py",
]

output_file = os.path.join(tests_dir, "all_tests.txt")

with open(output_file, "w", encoding="utf-8") as outfile:
    for fname in test_files:
        path = os.path.join(tests_dir, fname)
        if os.path.exists(path):
            outfile.write(f"\n\n# ===== {fname} =====\n\n")
            with open(path, "r", encoding="utf-8") as infile:
                outfile.write(infile.read())
        else:
            outfile.write(f"\n\n# ===== {fname} (NOT FOUND) =====\n\n")

print(f"✅ Merged {len(test_files)} files into {output_file}")


===== tests\test_auth_basic.py =====
# app/api/v1/tests/test_auth_basic.py


def test_register_success(client):
    response = client.post(
        "/auth/register",
        json={
            "email": "user1@example.com",
            "password": "strongpassword123",
        },
    )
    assert response.status_code == 201
    data = response.json()
    assert "id" in data
    assert data["email"] == "user1@example.com"
    assert "password" not in data
    assert "hashed_password" not in data


def test_register_duplicate_email(client):
    payload = {
        "email": "duplicate@example.com",
        "password": "password123",
    }
    r1 = client.post("/auth/register", json=payload)
    assert r1.status_code == 201

    r2 = client.post("/auth/register", json=payload)
    assert r2.status_code == 400
    body = r2.json()
    assert body["detail"] == "Email already registered"


def test_login_success_oauth2_form(client):
    email = "login_form@example.com"
    password = "password123"

    # register
    r = client.post("/auth/register", json={"email": email, "password": password})
    assert r.status_code == 201

    # login via OAuth2 form
    response = client.post(
        "/auth/login",
        data={"username": email, "password": password},
        headers={"Content-Type": "application/x-www-form-urlencoded"},
    )
    assert response.status_code == 200
    data = response.json()
    assert "access_token" in data
    assert "refresh_token" in data
    assert data["token_type"] == "bearer"


def test_login_success_json_body(client):
    email = "login_json@example.com"
    password = "password123"

    # register
    r = client.post("/auth/register", json={"email": email, "password": password})
    assert r.status_code == 201

    # login via JSON body
    response = client.post("/auth/login", json={"email": email, "password": password})
    assert response.status_code == 200
    data = response.json()
    assert "access_token" in data
    assert "refresh_token" in data
    assert data["token_type"] == "bearer"


def test_login_invalid_credentials(client):
    response = client.post(
        "/auth/login",
        data={"username": "notfound@example.com", "password": "wrongpassword"},
        headers={"Content-Type": "application/x-www-form-urlencoded"},
    )
    assert response.status_code == 401
    body = response.json()
    assert body["detail"] == "Invalid credentials"


===== tests\test_auth_failures.py =====
# tests/test_auth_failures.py
from jose import jwt
from app.core.config import settings


def test_me_without_token(client):
    """
    1️⃣ درخواست به route محافظت‌شده بدون ارسال توکن
    انتظار: 401 Unauthorized
    """
    response = client.get("/users/me")
    assert response.status_code == 401


def test_me_with_invalid_token(client):
    """
    2️⃣ ارسال توکن خراب / نامعتبر
    انتظار: 401 Unauthorized
    """
    response = client.get(
        "/users/me",
        headers={"Authorization": "Bearer invalid.token.value"},
    )
    assert response.status_code == 401


def test_me_user_not_found(client):
    """
    3️⃣ توکن معتبر ولی user مربوط به sub وجود ندارد
    (مثلاً user_id = 999)
    انتظار معماری ما: 401 Unauthorized
    """

    token = jwt.encode(
        {"sub": "999"},
        settings.secret_key,
        algorithm=settings.algorithm,
    )

    response = client.get(
        "/users/me",
        headers={"Authorization": f"Bearer {token}"},
    )

    assert response.status_code == 401


===== tests\test_auth_flow.py =====
# tests/test_auth_flow.py

def test_login_json_payload(client):
    email = "jsonlogin@example.com"
    password = "strongjsonpass"

    client.post("/auth/register", json={"email": email, "password": password})

    # login via JSON
    resp = client.post("/auth/login", json={"email": email, "password": password})
    assert resp.status_code == 200
    data = resp.json()
    assert "access_token" in data
    assert "refresh_token" in data


===== tests\test_imports.py =====
import os
import sys
import pytest
import importlib
import pkgutil

# مسیر پروژه
BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
sys.path.insert(0, BASE_DIR)


def iter_modules(package):
    """تمام ماژول‌های یک پکیج را yield می‌کند"""
    package_path = package.__path__
    for _, name, ispkg in pkgutil.walk_packages(package_path, package.__name__ + "."):
        yield name


@pytest.mark.parametrize("module_name", list(iter_modules(importlib.import_module("app"))))
def test_no_circular_imports(module_name):
    """
    تست می‌کند که هیچ circular import یا وابستگی اشتباه وجود نداشته باشد.
    """
    try:
        importlib.import_module(module_name)
    except ImportError as e:
        pytest.fail(f"ImportError in {module_name}: {e}")
    except Exception as e:
        # اگر خطای RuntimeError مربوط به circular import بود
        if "circular" in str(e).lower():
            pytest.fail(f"Circular import detected in {module_name}: {e}")


===== tests\test_refresh_flow.py =====
# tests/test_refresh_flow.py

def test_refresh_flow_success_and_rotation(client):
    email = "flow@example.com"
    password = "pass123456"

    # register
    r = client.post("/auth/register", json={"email": email, "password": password})
    assert r.status_code == 201

    # login (get initial tokens)
    login = client.post(
        "/auth/login",
        data={"username": email, "password": password},
        headers={"Content-Type": "application/x-www-form-urlencoded"},
    )
    assert login.status_code == 200
    body = login.json()
    assert "access_token" in body and "refresh_token" in body
    refresh_token = body["refresh_token"]

    # refresh (JSON)
    refresh = client.post("/auth/refresh", json={"refresh_token": refresh_token})
    assert refresh.status_code == 200
    refreshed = refresh.json()
    assert "access_token" in refreshed
    assert "refresh_token" in refreshed
    new_refresh = refreshed["refresh_token"]

    # old refresh must now be invalid (revoked)
    refresh_again = client.post("/auth/refresh", json={"refresh_token": refresh_token})
    assert refresh_again.status_code == 401
    assert refresh_again.json()["detail"] == "Invalid or expired refresh token"

    # new refresh must be valid
    refresh_new = client.post("/auth/refresh", json={"refresh_token": new_refresh})
    assert refresh_new.status_code == 200
    refreshed_2 = refresh_new.json()
    assert "access_token" in refreshed_2
    assert "refresh_token" in refreshed_2


def test_refresh_invalid_token(client):
    resp = client.post("/auth/refresh", json={"refresh_token": "non-existent-token"})
    assert resp.status_code == 401
    assert resp.json()["detail"] == "Invalid or expired refresh token"


===== tests\test_roles_permissions_tenants.py =====
import pytest
import uuid
from fastapi.testclient import TestClient
from sqlalchemy.orm import Session
from collections.abc import Generator

from app.main import app
from app.core.database import get_db, Base
from app.core.security import create_access_token
from app.models.user import User
from app.models.role import Role
from app.models.tenant import Tenant

client = TestClient(app)


@pytest.fixture
def db_session() -> Generator[Session, None, None]:
    """یک session دیتابیس برای تست‌ها فراهم می‌کند"""
    db = next(get_db())
    try:
        yield db
    finally:
        db.close()


@pytest.fixture(autouse=True)
def override_get_db(db_session: Session):
    """اطمینان از اینکه dependency get_db در runtime از همان session تست استفاده کند"""
    app.dependency_overrides[get_db] = lambda: db_session


@pytest.fixture(autouse=True)
def clean_db(db_session: Session):
    """پاک کردن تمام جداول قبل از هر تست تا حالت ایزوله تضمین شود"""
    for table in reversed(Base.metadata.sorted_tables):
        db_session.execute(table.delete())
    db_session.commit()


def create_tenant(db: Session, name: str | None = None) -> Tenant:
    """ایجاد یک tenant جدید و بازگرداندن آن"""
    tenant = Tenant(name=name or f"tenant-{uuid.uuid4()}")
    db.add(tenant)
    db.commit()
    db.refresh(tenant)
    return tenant


def create_user_with_roles(db: Session, tenant: Tenant, roles: list[str] | None = None):
    """
    کاربر می‌سازد، نقش‌ها را به او اختصاص می‌دهد و توکن JWT برمی‌گرداند.
    - roles: لیست نام نقش‌ها (مثلاً ["admin", "user"])
    """
    email = f"{uuid.uuid4()}@example.com"
    user = User(email=email, hashed_password="fakehashed", tenant_id=tenant.id)
    db.add(user)
    db.commit()
    db.refresh(user)

    if roles:
        for rname in roles:
            role = db.query(Role).filter(Role.name == rname, Role.tenant_id == tenant.id).first()
            if not role:
                role = Role(name=rname)
                db.add(role)
                db.commit()
                db.refresh(role)
            # فرض: رابطه many-to-many user.roles موجود است
            user.roles.append(role)
        db.commit()
        db.refresh(user)

    token = create_access_token(subject=str(user.id))
    return token, user


# -------------------------
# تست‌های ترکیبی role + tenant
# -------------------------


def test_admin_access_same_tenant(db_session: Session):
    """
    کاربر admin در tenant درست باید بتواند به داشبورد tenant دسترسی داشته باشد (200).
    """
    t = create_tenant(db_session, "tenant-A")
    token, user = create_user_with_roles(db_session, t, roles=["admin"])

    resp = client.get(f"/tenants/{t.id}/dashboard", headers={"Authorization": f"Bearer {token}"})
    assert resp.status_code == 200


def test_admin_access_other_tenant_forbidden(db_session: Session):
    """
    کاربر admin در tenant B نباید به داشبورد tenant A دسترسی داشته باشد (403).
    """
    tA = create_tenant(db_session, "tenant-A")
    tB = create_tenant(db_session, "tenant-B")

    token_b, user_b = create_user_with_roles(db_session, tB, roles=["admin"])

    resp = client.get(f"/tenants/{tA.id}/dashboard", headers={"Authorization": f"Bearer {token_b}"})
    assert resp.status_code == 403


def test_user_role_forbidden(db_session: Session):
    """
    کاربر با نقش user در tenant خودش نباید به داشبورد tenant دسترسی admin‌گونه داشته باشد (403).
    """
    t = create_tenant(db_session, "tenant-C")
    token, user = create_user_with_roles(db_session, t, roles=["user"])

    resp = client.get(f"/tenants/{t.id}/dashboard", headers={"Authorization": f"Bearer {token}"})
    assert resp.status_code == 403


def test_multi_role_user_has_admin_access(db_session: Session):
    """
    کاربر با نقش‌های user و admin باید دسترسی admin را داشته باشد (ترکیب نقش‌ها).
    """
    t = create_tenant(db_session, "tenant-D")
    token, user = create_user_with_roles(db_session, t, roles=["user", "admin"])

    resp = client.get(f"/tenants/{t.id}/dashboard", headers={"Authorization": f"Bearer {token}"})
    assert resp.status_code == 200


def test_user_without_role_forbidden(db_session: Session):
    """
    کاربر بدون هیچ نقش مشخصی نباید به داشبورد tenant دسترسی داشته باشد (403).
    """
    t = create_tenant(db_session, "tenant-E")
    token, user = create_user_with_roles(db_session, t, roles=None)

    resp = client.get(f"/tenants/{t.id}/dashboard", headers={"Authorization": f"Bearer {token}"})
    assert resp.status_code == 403


def test_admin_global_endpoint_requires_admin_role(db_session: Session):
    """
    endpoint سراسری admin (مثلاً /admin/dashboard) فقط برای نقش admin قابل دسترسی است.
    """
    t = create_tenant(db_session, "tenant-global")
    token_admin, _ = create_user_with_roles(db_session, t, roles=["admin"])
    token_user, _ = create_user_with_roles(db_session, t, roles=["user"])

    resp_ok = client.get("/admin/dashboard", headers={"Authorization": f"Bearer {token_admin}"})
    assert resp_ok.status_code == 200

    resp_forbidden = client.get("/admin/dashboard", headers={"Authorization": f"Bearer {token_user}"})
    assert resp_forbidden.status_code == 403


===== tests\test_roles.py =====
import pytest
import uuid
from fastapi.testclient import TestClient
from sqlalchemy.orm import Session
from collections.abc import Generator

from app.main import app
from app.core.database import get_db, Base
from app.models import tenant
from app.models.user import User
from app.models.role import Role
from app.core.security import create_access_token

client = TestClient(app)


@pytest.fixture
def db_session() -> Generator[Session, None, None]:
    """Fixture برای گرفتن یک session دیتابیس"""
    db = next(get_db())
    try:
        yield db
    finally:
        db.close()


@pytest.fixture(autouse=True)
def override_get_db(db_session: Session):
    """استفاده از همان session در runtime و تست"""
    app.dependency_overrides[get_db] = lambda: db_session


@pytest.fixture(autouse=True)
def clean_db(db_session: Session):
    """پاک کردن دیتابیس قبل از هر تست"""
    for table in reversed(Base.metadata.sorted_tables):
        db_session.execute(table.delete())
    db_session.commit()


def create_user_with_role(db: Session, role_name: str | None):
    """کاربر تستی بساز و در صورت نیاز نقش بده"""
    email = f"{uuid.uuid4()}@example.com"  # ایمیل یکتا
    user = User(email=email, hashed_password="fakehashed", tenant_id=1)
    db.add(user)
    db.commit()
    db.refresh(user)

    if role_name:
        role = db.query(Role).filter(Role.name == role_name, Role.tenant_id == tenant.id).first()
        if not role:
            role = Role(name=role_name)
            db.add(role)
            db.commit()
            db.refresh(role)
        user.roles.append(role)
        db.commit()
        db.refresh(user)

    token = create_access_token(subject=str(user.id))
    return token, user


def test_user_without_role(db_session: Session):
    token, user = create_user_with_role(db_session, None)
    response = client.get(
        "/admin/dashboard", headers={"Authorization": f"Bearer {token}"}
    )
    assert response.status_code == 403


def test_user_with_admin_role(db_session: Session):
    token, user = create_user_with_role(db_session, "admin")
    response = client.get(
        "/admin/dashboard", headers={"Authorization": f"Bearer {token}"}
    )
    assert response.status_code == 200
    assert "Welcome admin" in response.json()["msg"]


def test_user_with_user_role(db_session: Session):
    token, user = create_user_with_role(db_session, "user")
    response = client.get(
        "/admin/dashboard", headers={"Authorization": f"Bearer {token}"}
    )
    assert response.status_code == 403


===== tests\test_service_dependencies.py =====
import os
import pytest

SERVICE_DIR = os.path.join(os.path.dirname(os.path.dirname(__file__)), "app", "services")

@pytest.mark.parametrize("filename", [f for f in os.listdir(SERVICE_DIR) if f.endswith(".py")])
def test_services_do_not_import_api(filename):
    """
    سرویس‌ها نباید چیزی از api import کنند.
    """
    with open(os.path.join(SERVICE_DIR, filename), "r", encoding="utf-8") as f:
        content = f.read()
        assert "app.api" not in content, f"{filename} imports api layer!"
        assert "fastapi" not in content, f"{filename} imports FastAPI (should be pure business logic)"


===== tests\test_tenant_isolation.py =====
import pytest
import uuid
from sqlalchemy.orm import Session
from app.core.database import get_db, Base, engine

from app.models.user import User
from app.models.tenant import Tenant

# -------------------------
# ایزوله کردن دیتابیس بین تست‌ها
# -------------------------


@pytest.fixture(autouse=True)
def reset_db():
    # drop & create برای شروع تست
    Base.metadata.drop_all(bind=engine)
    Base.metadata.create_all(bind=engine)
    yield
    # teardown (اختیاری)
    Base.metadata.drop_all(bind=engine)


# -------------------------
# Helper ها برای داده تست
# -------------------------


def unique_email(base_local: str = "user", domain: str = "example.com") -> str:
    suffix = uuid.uuid4().hex[:6]
    return f"{base_local}_{suffix}@{domain}"


def create_tenant(db: Session, name: str = None) -> Tenant:
    if name is None:
        # تولید نام یکتا برای جلوگیری از خطای UNIQUE
        name = f"tenant_{uuid.uuid4().hex[:6]}"
    else:
        # اگر اسم ثابت داده شد، suffix تصادفی اضافه کن تا همیشه یکتا باشد
        name = f"{name}_{uuid.uuid4().hex[:6]}"
    tenant = Tenant(name=name)
    db.add(tenant)
    db.commit()
    db.refresh(tenant)
    return tenant


def create_user(db: Session, email: str, tenant: Tenant) -> User:
    # حتی اگر ایمیل ثابت پاس داده شود، آن را یکتا می‌کنیم
    local, domain = email.split("@")
    email_unique = unique_email(local, domain)
    user = User(email=email_unique, hashed_password="fakehashed", tenant_id=tenant.id)
    db.add(user)
    db.commit()
    db.refresh(user)
    return user


# -------------------------
# تست‌های Cross-Tenant
# -------------------------


def test_cross_tenant_read_forbidden(client):
    """
    کاربر tenant A نباید بتواند کاربران tenant B را بخواند.
    """
    db = next(get_db())
    tenant_a = create_tenant(db, "tenantA")
    tenant_b = create_tenant(db, "tenantB")
    user_b = create_user(db, "userb@example.com", tenant_b)

    # شبیه‌سازی درخواست با tenant A
    response = client.get(
        "/users/", headers={"Authorization": f"Bearer faketoken-for-{tenant_a.id}"}
    )
    assert response.status_code in (401, 403)


def test_cross_tenant_update_forbidden(client):
    """
    کاربر tenant A نباید بتواند کاربر tenant B را آپدیت کند.
    """
    db = next(get_db())
    tenant_a = create_tenant(db, "tenantA")
    tenant_b = create_tenant(db, "tenantB")
    user_b = create_user(db, "userb@example.com", tenant_b)

    response = client.put(
        f"/users/{user_b.id}",
        json={"email": "hacked@example.com"},
        headers={"Authorization": f"Bearer faketoken-for-{tenant_a.id}"},
    )
    assert response.status_code in (401, 403)


def test_cross_tenant_delete_forbidden(client):
    """
    کاربر tenant A نباید بتواند کاربر tenant B را حذف کند.
    """
    db = next(get_db())
    tenant_a = create_tenant(db, "tenantA")
    tenant_b = create_tenant(db, "tenantB")
    user_b = create_user(db, "userb@example.com", tenant_b)

    response = client.delete(
        f"/users/{user_b.id}",
        headers={"Authorization": f"Bearer faketoken-for-{tenant_a.id}"},
    )
    assert response.status_code in (401, 403)


===== tests\test_users_me.py =====
# tests/test_users_me.py

def test_me_authenticated(client):
    email = "meuser@example.com"
    password = "meuserpass123"

    # register
    r = client.post("/auth/register", json={"email": email, "password": password})
    assert r.status_code == 201

    # login (get tokens)
    login = client.post(
        "/auth/login",
        data={"username": email, "password": password},
        headers={"Content-Type": "application/x-www-form-urlencoded"},
    )
    assert login.status_code == 200
    tokens = login.json()
    access_token = tokens["access_token"]

    # /users/me with Authorization header
    me = client.get("/users/me", headers={"Authorization": f"Bearer {access_token}"})
    assert me.status_code == 200
    body = me.json()
    assert body["email"] == email
    assert "id" in body


def test_me_unauthenticated(client):
    me = client.get("/users/me")
    assert me.status_code == 401
    assert me.json()["detail"] in (
        "Not authenticated",
        "Could not validate credentials",
    )


===== app\api\v1\users.py =====
from fastapi import APIRouter, Depends
from app.core.deps import get_current_user, require_role

from app.models.user import User

router = APIRouter(prefix="/users", tags=["users"])


@router.get("/me")
def read_current_user(
    current_user: User = Depends(get_current_user),
):
    return {
        "id": current_user.id,
        "email": current_user.email,
    }


===== app\core\security.py =====
from datetime import datetime, timedelta, timezone
from typing import Optional
from jose import jwt, JWTError
from passlib.context import CryptContext
import uuid
from fastapi.security import OAuth2PasswordBearer
from app.core.config import settings

pwd_context = CryptContext(schemes=["argon2"], deprecated="auto")

# -------------------------
# OAuth2 scheme
# -------------------------
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="auth/login")


# -------------------------
# Password helpers
# -------------------------
def hash_password(password: str) -> str:
    return pwd_context.hash(password)


def verify_password(plain_password: str, hashed_password: str) -> bool:
    return pwd_context.verify(plain_password, hashed_password)


# -------------------------
# JWT helpers
# -------------------------
def create_access_token(subject: str, expires_delta: Optional[timedelta] = None) -> str:
    """
    Create a short-lived access token (default 30 minutes).
    """
    to_encode = {"sub": subject}
    expire = datetime.now(timezone.utc) + (expires_delta or timedelta(minutes=30))
    to_encode.update({"exp": expire})
    return jwt.encode(to_encode, settings.secret_key, algorithm=settings.algorithm)


def create_refresh_token(subject: str) -> str:
    """
    Create a long-lived refresh token with unique jti.
    """
    to_encode = {"sub": subject, "type": "refresh", "jti": str(uuid.uuid4())}
    return jwt.encode(to_encode, settings.secret_key, algorithm=settings.algorithm)


def decode_token(token: str) -> dict:
    """
    Decode JWT token and return payload.
    Raises ValueError if token is invalid.
    """
    try:
        return jwt.decode(token, settings.secret_key, algorithms=[settings.algorithm])
    except JWTError:
        raise ValueError("Invalid token")


===== app\core\deps.py =====
# app/core/deps.py
from fastapi import Depends, HTTPException, status
from sqlalchemy.orm import Session

from app.core.database import get_db
from app.models.user import User
from app.models.tenant import Tenant
from app.core.security import oauth2_scheme, decode_token


# -------------------------
# User dependency
# -------------------------
def get_current_user(
    db: Session = Depends(get_db),
    token: str = Depends(oauth2_scheme),
) -> User:
    """
    Resolve current user from JWT token.
    """
    try:
        payload = decode_token(token)
    except ValueError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid token",
        )

    user_id: str = payload.get("sub")
    if not user_id:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid token",
        )

    user = db.query(User).filter(User.id == int(user_id)).first()
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="User not found",
        )
    return user


# -------------------------
# Tenant dependency
# -------------------------
def get_current_tenant(
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user),
) -> Tenant:
    """
    Resolve current tenant from current user.
    """
    tenant = db.query(Tenant).filter(Tenant.id == current_user.tenant_id).first()
    if not tenant:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Tenant not found or mismatch",
        )
    return tenant


# -------------------------
# Role dependency
# -------------------------
def require_role(role_name: str):
    """
    Dependency برای enforce کردن نقش کاربر.
    استفاده: current_user = Depends(require_role("admin"))
    """
    def role_dependency(current_user: User = Depends(get_current_user)):
        if current_user.role != role_name:
            # پیام خطا ساده و امن، بدون افشای role مورد انتظار
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="Forbidden",
            )
        return current_user

    return role_dependency


===== tests\conftest.py =====
# tests/conftest.py
import os
import tempfile
import shutil
import pytest
from importlib import import_module
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from fastapi.testclient import TestClient
from fastapi import FastAPI
from alembic import command
from alembic.config import Config

# create a temporary directory for test DB to avoid file lock issues
TMP_DIR = os.path.join(os.path.dirname(__file__), ".tmp_test")
os.makedirs(TMP_DIR, exist_ok=True)
TEST_DB_PATH = os.path.join(TMP_DIR, "test.db")
TEST_DB_URL = f"sqlite:///{TEST_DB_PATH}"

# Ensure application uses test DB before importing app modules
os.environ["DATABASE_URL"] = TEST_DB_URL


def run_migrations():
    alembic_ini = os.path.join(os.path.dirname(__file__), "..", "alembic.ini")
    alembic_cfg = Config(alembic_ini)
    alembic_cfg.set_main_option("sqlalchemy.url", TEST_DB_URL)
    command.upgrade(alembic_cfg, "head")


# import app after DATABASE_URL is set
try:
    main_mod = import_module("app.main")
    app = getattr(main_mod, "app", None)
except Exception as e:
    app = None
    import_err = e

if app is None or not isinstance(app, FastAPI):
    raise RuntimeError(
        "Could not import FastAPI instance from app.main. Import error: "
        f"{locals().get('import_err')}"
    )


@pytest.fixture(scope="session")
def engine():
    # remove old DB if exists
    if os.path.exists(TEST_DB_PATH):
        os.remove(TEST_DB_PATH)
    eng = create_engine(TEST_DB_URL, connect_args={"check_same_thread": False})
    yield eng
    # ensure engine disposed
    try:
        eng.dispose()
    except Exception:
        pass


@pytest.fixture(scope="session")
def TestingSessionLocal(engine):
    return sessionmaker(bind=engine, autocommit=False, autoflush=False)


@pytest.fixture(scope="session", autouse=True)
def setup_database(engine):
    # run migrations on test DB
    run_migrations()
    yield
    # teardown: dispose engine and remove tmp dir
    try:
        engine.dispose()
    except Exception:
        pass
    # remove temp dir and files
    if os.path.exists(TMP_DIR):
        shutil.rmtree(TMP_DIR, ignore_errors=True)


@pytest.fixture(autouse=True)
def override_db(TestingSessionLocal):
    """Override get_db dependency for each test to use the test session."""
    from app.core.database import get_db as real_get_db  # import after env set

    def _override():
        db = TestingSessionLocal()
        try:
            # ensure default tenant exists if app expects it
            try:
                import app.models.tenant as tenant_model

                tenant = db.query(tenant_model.Tenant).first()
                if not tenant:
                    tenant = tenant_model.Tenant(name="default")
                    db.add(tenant)
                    db.commit()
                    db.refresh(tenant)
            except Exception:
                pass
            yield db
        finally:
            # rollback any pending transaction and close
            try:
                db.rollback()
            except Exception:
                pass
            db.close()

    app.dependency_overrides[real_get_db] = _override
    yield
    app.dependency_overrides.clear()


@pytest.fixture
def client():
    # Use context manager to ensure proper shutdown and cleanup
    with TestClient(app) as c:
        yield c


